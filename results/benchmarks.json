{
    "bench_pipeline.PipelineSuite.peakmem_process_all": {
        "code": "class PipelineSuite:\n    def peakmem_process_all(self, engine, context):\n        \"\"\"Measures maximum resident set size (RAM).\"\"\"\n        self._run_once(engine, context)\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "name": "bench_pipeline.PipelineSuite.peakmem_process_all",
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "timeout": 300,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "36078c27c58a9f59757961d4a7c9c3b9e50c2108ce85f88b25007f9c65043450"
    },
    "bench_pipeline.PipelineSuite.time_process_all": {
        "code": "class PipelineSuite:\n    def time_process_all(self, engine, context):\n        \"\"\"Measures parsing speed (seconds).\"\"\"\n        self._run_once(engine, context)\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "min_run_count": 2,
        "name": "bench_pipeline.PipelineSuite.time_process_all",
        "number": 0,
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "aa86255afc3e31045d4ca057d629ea302358f79157c77ae82c18c287f6275e0c",
        "warmup_time": -1
    },
    "bench_pipeline.PipelineSuite.track_energy": {
        "code": "class PipelineSuite:\n    def track_energy(self, engine, context):\n        \"\"\"\n        Routes execution based on engine/context and tracks energy with CodeCarbon.\n        Stores last measured energy per engine in self._energy_joules.\n        \"\"\"\n        is_ci = os.getenv('CI') or os.getenv('GITHUB_ACTIONS')\n        iterations = 500 if engine == 'rust' else 50\n        energy_kwh = None\n        start_cpu = time.process_time()\n        start_wall = time.perf_counter()\n        os.environ[\"CODECARBON_CARBON_INTENSITY\"] = \"475\"\n        if not is_ci:\n            try:\n              from codecarbon import OfflineEmissionsTracker\n              tracker = OfflineEmissionsTracker(measure_power_secs=0.1, log_level=\"CRITICAL\", country_iso_code=\"USA\")\n              tracker.start()\n    \n              result = None\n              try:\n                   self._run_repeatedly(engine, context, iterations)\n              finally:\n                   tracker.stop()\n    \n              energy_kwh = getattr(tracker, \"total_energy\", 0)\n            except Exception:\n                energy_kwh = 0\n            # Store energy per engine in Joules\n        else:\n            self._run_repeatedly(engine, context, iterations)\n        cpu_time = time.process_time() - start_cpu\n        wall_time = time.perf_counter() - start_wall\n    \n        # Use CPU-based estimation if CodeCarbon didn't work or returned 0\n        if energy_kwh == 0 or energy_kwh is None:\n            # CPU utilization factor (how much of wall time was CPU work)\n            cpu_utilization = min(cpu_time / wall_time, 1.0) if wall_time > 0 else 1.0\n    \n            # Power estimates for GitHub Actions runner (2-core VM)\n            base_power_w = 10   # System idle power\n            cpu_power_w = 30 * cpu_utilization  # CPU power under load\n            avg_power_w = base_power_w + cpu_power_w\n    \n            # Energy in kWh\n            energy_kwh = (avg_power_w * wall_time / 3600) / 1000\n            print(\"energy kwh is \", energy_kwh)\n    \n        # Convert to Joules per iteration\n        energy_joules_per_iteration = (energy_kwh * 3_600_000) / iterations\n    \n        return energy_joules_per_iteration\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "name": "bench_pipeline.PipelineSuite.track_energy",
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "timeout": 300,
        "type": "track",
        "unit": "J",
        "version": "833342fbcc7ee73200648b7795e4e8dee062a16019cccdb894b6b6d195e3a6e4"
    },
    "bench_pipeline.PipelineSuite.track_parsing_latency": {
        "code": "class PipelineSuite:\n    def track_parsing_latency(self, engine, context):\n        \"\"\"Records single-pass parsing latency (seconds).\"\"\"\n        start = time.perf_counter()\n        self._run_once(engine, context)\n        end = time.perf_counter()\n        return end - start\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "name": "bench_pipeline.PipelineSuite.track_parsing_latency",
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "timeout": 300,
        "type": "track",
        "unit": "s",
        "version": "57c4182dc50cdb3306a452411c5dd80f878357e4a027acf350a54ce6ce9d5706"
    },
    "energy_ci.EnergyPythonCI.track_energy": {
        "code": "class EnergyPythonCI:\n    def track_energy(self):\n        path = Path(\"eco-ci-python.json\")\n        if not path.exists():\n            return None\n        return json.loads(path.read_text())[\"energy_joules\"]",
        "name": "energy_ci.EnergyPythonCI.track_energy",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "J",
        "version": "1"
    },
    "energy_ci.EnergyRustCI.track_energy": {
        "code": "class EnergyRustCI:\n    def track_energy(self):\n        path = Path(\"eco-ci-rust.json\")\n        if not path.exists():\n            return None  # ASV will mark as missing locally\n        return json.loads(path.read_text())[\"energy_joules\"]",
        "name": "energy_ci.EnergyRustCI.track_energy",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "J",
        "version": "1"
    },
    "version": 2
}