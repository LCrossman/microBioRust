{
    "bench_pipeline.PipelineSuite.peakmem_process_all": {
        "code": "class PipelineSuite:\n    def peakmem_process_all(self, engine, context):\n        \"\"\"Measures maximum resident set size (RAM).\"\"\"\n        self._run_logic(engine, context)\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "name": "bench_pipeline.PipelineSuite.peakmem_process_all",
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "timeout": 300,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "873522a4606ae3c32ca6367ea3babe361a6cc5f138ed1001e86caee07719b53b"
    },
    "bench_pipeline.PipelineSuite.time_process_all": {
        "code": "class PipelineSuite:\n    def time_process_all(self, engine, context):\n        \"\"\"Measures parsing speed (seconds).\"\"\"\n        self._run_logic(engine, context)\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "min_run_count": 2,
        "name": "bench_pipeline.PipelineSuite.time_process_all",
        "number": 0,
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 300,
        "type": "time",
        "unit": "seconds",
        "version": "d715bed031b1f651a953a4159692f7755890fa8f363087f5f4b55ca974d92855",
        "warmup_time": -1
    },
    "bench_pipeline.PipelineSuite.track_energy": {
        "code": "class PipelineSuite:\n    def track_energy(self, engine, context):\n        \"\"\"\n        Returns energy consumed (Joules) for this engine/context using CodeCarbon.\n        ASV can plot Rust vs Python separately.\n        \"\"\"\n        self._run_logic(engine, context)\n        return self._energy_joules[f\"{engine}_{context}\"]\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "name": "bench_pipeline.PipelineSuite.track_energy",
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "timeout": 300,
        "type": "track",
        "unit": "J",
        "version": "ac379b92e3c40e093884ece5d0e8fe34ff7ff689fb44611ea18b7f81c7a59163"
    },
    "bench_pipeline.PipelineSuite.track_parsing_latency": {
        "code": "class PipelineSuite:\n    def track_parsing_latency(self, engine, context):\n        \"\"\"Records single-pass parsing latency (seconds).\"\"\"\n        start = time.perf_counter()\n        self._run_logic(engine, context)\n        end = time.perf_counter()\n        return end - start\n\n    def setup(self, engine, context):\n        bench_dir = os.path.dirname(__file__)\n        self.filepath = os.path.join(bench_dir, \"Rhiz3841.gbk.gb\")\n    \n        # CLI scripts for pipeline mode\n        self.rust_cli = os.path.join(bench_dir, \"rust_via_python_countgbk2faa.py\")\n        self.python_cli = os.path.join(bench_dir, \"bp_equivalent_gbktofaacount.py\")\n    \n        if not os.path.exists(self.filepath):\n            raise FileNotFoundError(f\"Missing benchmark file: {self.filepath}\")\n    \n        # Initialize energy dictionary if not already present\n        if not hasattr(self, \"_energy_joules\"):\n            self._energy_joules = {}",
        "name": "bench_pipeline.PipelineSuite.track_parsing_latency",
        "param_names": [
            "engine",
            "context"
        ],
        "params": [
            [
                "'rust'",
                "'python'"
            ],
            [
                "'interactive'",
                "'pipeline'"
            ]
        ],
        "timeout": 300,
        "type": "track",
        "unit": "s",
        "version": "66ce0ec3cf156cb397fc87a1f8b0b0a146f02dacc04cd9c7bda989306f900421"
    },
    "energy_ci.EnergyPythonCI.track_energy": {
        "code": "class EnergyPythonCI:\n    def track_energy(self):\n        path = Path(\"eco-ci-python.json\")\n        if not path.exists():\n            return None\n        return json.loads(path.read_text())[\"energy_joules\"]",
        "name": "energy_ci.EnergyPythonCI.track_energy",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "J",
        "version": "1"
    },
    "energy_ci.EnergyRustCI.track_energy": {
        "code": "class EnergyRustCI:\n    def track_energy(self):\n        path = Path(\"eco-ci-rust.json\")\n        if not path.exists():\n            return None  # ASV will mark as missing locally\n        return json.loads(path.read_text())[\"energy_joules\"]",
        "name": "energy_ci.EnergyRustCI.track_energy",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "J",
        "version": "1"
    },
    "version": 2
}